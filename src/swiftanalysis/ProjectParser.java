package swiftanalysis;

import org.antlr.v4.runtime.*;
import swiftanalysis.generated.Swift3Lexer;
import swiftanalysis.generated.Swift3Parser;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Stream;

/**
 * Responsible for finding all Swift files in a project and generating parse trees.
 */
public class ProjectParser {

	private static int numberOfFilesBeforeClearingCache = 20;
    private static AtomicInteger numFiles = new AtomicInteger(0);

    /**
     * Parses all Swift files in the given project path.
     *
     * @param projectPath absolute path to the Swift project
     * @return a stream of parse trees of all Swift files in the project
     */
    Stream<AST> parseProject(File projectPath) {
        Stream<File> files = getProjectFiles(projectPath);
        return files.map(ProjectParser::parseFile);
    }

    /**
     * Generates a parse tree from a given Swift file.
     * Uses the lexer and parser generated by ANTLR.
     *
     * @param file the Swift file
     * @return the parse tree
     */
    private static AST parseFile(File file) {
//        System.out.println("Parsing " + file.getAbsolutePath());
        CharStream input = null;
        try {
            input = new ANTLRInputStream(new FileReader(file));
        } catch (IOException e) {
            System.err.println("Could not read " + file.getAbsolutePath());
        }
        Swift3Parser parser = getSwiftParser(input);
        clearDFACache(parser);
        try {
        	System.out.println(file.getAbsolutePath());
            return new AST(file, parser.top_level(), parser);
        } catch (ErrorListener.ParseError e) {
        	System.out.println("error: "+file.getAbsolutePath());
            System.out.println(e.getMsg());
            return new AST(file, e);
        }
    }

    /**
     * Returns a Swift Parser with a given input stream
     *
     * @param input the input stream for the parser
     * @return the Swift Parser
     */
    private static Swift3Parser getSwiftParser(CharStream input) {
        Swift3Lexer lexer = new Swift3Lexer(input);
        lexer.removeErrorListeners();
        lexer.addErrorListener(new ErrorListener());
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        Swift3Parser parser = new Swift3Parser(tokens);
        parser.removeErrorListeners();
        parser.addErrorListener(new ErrorListener());
        return parser;
    }

    /**
     * Returns a stream of all Swift files in a given project path.
     *
     * @param projectPath the absolute project path
     * @return a stream of files in the project path
     */
    private Stream<File> getProjectFiles(File projectPath) {
        Stream.Builder<File> streamBuilder = Stream.builder();
        addSwiftFiles(projectPath, streamBuilder);
        return streamBuilder.build();
    }

    /**
     * Recursively adds all files ending with .swift to the given stream builder
     *
     * @param file the file or directory to add
     * @param streamBuilder all files will be added to this stream builder
     */
    private void addSwiftFiles(File file, Stream.Builder<File> streamBuilder) {
        if (file.isFile()) {
            if (file.getName().endsWith(".swift")) {
                streamBuilder.add(file);
            }
        } else if (file.isDirectory()) {
            File[] files = file.listFiles();
            if (files != null) {
                for (File f : files) {
                    addSwiftFiles(f, streamBuilder);
                }
            } else {
                System.err.println("Could not open " + file.getAbsolutePath());
            }
        }
    }
    
    /**
     * Clears the DFA cache, reducing memory usage after specified number of files are parsed.
     *
     * @param parser current SwiftParser instance
     */
    private static void clearDFACache(Swift3Parser parser) {
        numFiles.incrementAndGet();
        if (numFiles.compareAndSet(numberOfFilesBeforeClearingCache, 0)) {
        	//System.out.println("cleared DFA");
            parser.getInterpreter().clearDFA();
        }
    }

    /**
     * Error listener for the ANTLR Lexer and Parser that throws an exception on parse error.
     */
    public static class ErrorListener extends BaseErrorListener {
        public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
            throw new ParseError(line, charPositionInLine, msg);
        }

        /**
         * Parse error that will be thrown.
         */
        public class ParseError extends RuntimeException {

            /**
             * line number
             */
            private int line;

            /**
             * character position in the line
             */
            private int charPositionInLine;

            /**
             * message
             */
            private String msg;

            /**
             * Constructs a parse error with line, character position in that line and a message.
             *
             * @param line line number
             * @param charPositionInLine offset of the parse error in the line
             * @param msg descriptive message of the error
             */
            ParseError(int line, int charPositionInLine, String msg) {
                this.line = line;
                this.charPositionInLine = charPositionInLine;
                this.msg = msg;
            }

            /**
             * Returns the line number.
             *
             * @return the line number
             */
            public int getLine() {
                return line;
            }

            /**
             * Returns offset of the parse error in the line.
             *
             * @return offset of the parse error in the line
             */
            public int getCharPositionInLine() {
                return charPositionInLine;
            }

            /**
             * Returns a descriptive message.
             *
             * @return message
             */
            public String getMsg() {
                return msg;
            }
        }
    }
}
